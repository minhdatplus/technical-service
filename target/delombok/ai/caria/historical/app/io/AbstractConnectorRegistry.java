// Generated by delombok at Wed May 26 23:25:48 ICT 2021
package ai.caria.historical.app.io;

import ai.caria.historical.app.io.translator.ExceptionTranslator;
import ai.caria.historical.app.io.translator.RequestTranslator;
import ai.caria.historical.app.io.translator.ResponseTranslator;
import ai.caria.historical.core.handler.HistoricalHandler;
import ai.caria.historical.message.HistoricalRequest;
import io.gridgo.connector.Connector;
import io.gridgo.connector.impl.factories.DefaultConnectorFactory;
import io.gridgo.framework.impl.NonameComponentLifecycle;
import io.gridgo.framework.support.Message;
import io.gridgo.utils.helper.Loggable;
import lombok.NonNull;
import org.apache.commons.lang3.StringUtils;
import org.joo.promise4j.Deferred;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;
import static lombok.AccessLevel.PROTECTED;

public abstract class AbstractConnectorRegistry extends NonameComponentLifecycle implements Loggable {
    @java.lang.SuppressWarnings("all")
    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(AbstractConnectorRegistry.class);
    @NonNull
    private HistoricalHandler bjHandler;
    @NonNull
    private String httpEndpoint;
    private List<Connector> connectors;
    @NonNull
    private Class<? extends Connectors> connectorRegistry;
    @NonNull
    private RequestTranslator requestTranslator;
    @NonNull
    private ResponseTranslator responseTranslator;
    @NonNull
    private ExceptionTranslator exceptionTranslator;

    @Override
    protected void onStart() {
        java.lang.reflect.Method[] declaredMethods = connectorRegistry.getDeclaredMethods();
        io.gridgo.connector.impl.factories.DefaultConnectorFactory factory = new DefaultConnectorFactory();
        connectors = new ArrayList<>();
        for (java.lang.reflect.Method method : declaredMethods) {
            if (!isValidAnnotated(method)) continue;
            ai.caria.historical.app.io.Endpoint annotation = method.getAnnotation(Endpoint.class);
            String endpoint = endPoint(httpEndpoint, annotation);
            getLogger().debug("Register endpoint: {}", endpoint);
            io.gridgo.connector.Connector connector = factory.createConnector(endpoint);
            connector.start();
            if (connector.getConsumer().isEmpty()) continue;
            io.gridgo.connector.Consumer consumer = connector.getConsumer().get();
            consumer.subscribe(((message, deferred) -> onRequest(message, deferred, annotation.request())));
            connectors.add(connector);
        }
    }

    @Override
    protected void onStop() {
        connectors.forEach(Connector::stop);
    }

    private String endPoint(String httpEndpoint, Endpoint annotation) {
        java.lang.StringBuilder sb = new StringBuilder(httpEndpoint);
        sb.append("/[");
        sb.append(annotation.path());
        sb.append("]");
        sb.append("?method=");
        sb.append(annotation.method().asString());
        if (StringUtils.isNotBlank(annotation.prometheusPrefix())) {
            sb.append("&enablePrometheus=true&prometheusPrefix=");
            sb.append(annotation.prometheusPrefix());
        }
        return sb.toString();
    }

    private boolean isValidAnnotated(Method method) {
        int modifiers = method.getModifiers();
        return method.isAnnotationPresent(Endpoint.class) && !Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers);
    }

    private void onRequest(Message message, Deferred<Message, Exception> deferred, Class<? extends HistoricalRequest> type) {
        ai.caria.historical.message.HistoricalRequest request = requestTranslator.translate(message, type);
        bjHandler.handle(request).done(res -> deferred.resolve(responseTranslator.translate(res))).fail(ex -> deferred.resolve(exceptionTranslator.translate(request, ex)));
    }

    @java.lang.SuppressWarnings("all")
    protected AbstractConnectorRegistry(@NonNull final HistoricalHandler bjHandler, @NonNull final String httpEndpoint, final List<Connector> connectors, @NonNull final Class<? extends Connectors> connectorRegistry, @NonNull final RequestTranslator requestTranslator, @NonNull final ResponseTranslator responseTranslator, @NonNull final ExceptionTranslator exceptionTranslator) {
        if (bjHandler == null) {
            throw new java.lang.NullPointerException("bjHandler is marked @NonNull but is null");
        }
        if (httpEndpoint == null) {
            throw new java.lang.NullPointerException("httpEndpoint is marked @NonNull but is null");
        }
        if (connectorRegistry == null) {
            throw new java.lang.NullPointerException("connectorRegistry is marked @NonNull but is null");
        }
        if (requestTranslator == null) {
            throw new java.lang.NullPointerException("requestTranslator is marked @NonNull but is null");
        }
        if (responseTranslator == null) {
            throw new java.lang.NullPointerException("responseTranslator is marked @NonNull but is null");
        }
        if (exceptionTranslator == null) {
            throw new java.lang.NullPointerException("exceptionTranslator is marked @NonNull but is null");
        }
        this.bjHandler = bjHandler;
        this.httpEndpoint = httpEndpoint;
        this.connectors = connectors;
        this.connectorRegistry = connectorRegistry;
        this.requestTranslator = requestTranslator;
        this.responseTranslator = responseTranslator;
        this.exceptionTranslator = exceptionTranslator;
    }
}
